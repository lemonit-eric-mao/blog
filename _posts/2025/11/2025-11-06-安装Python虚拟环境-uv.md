---
title: "安装 Python 虚拟环境工具 **uv**"
date: "2025-11-06"
categories: 
  - "Python"
---



# 安装 Python 虚拟环境工具 **uv**



## 下载离线包

### Windows

> https://github.com/astral-sh/uv/releases/download/0.9.7/uv-x86_64-pc-windows-msvc.zip

### Linux

> https://github.com/astral-sh/uv/releases/download/0.9.7/uv-x86_64-unknown-linux-gnu.tar.gz



# 🧭 UV 安装与使用指南



## Windows[官方安装教程](https://docs.astral.sh/uv/getting-started/installation/#__tabbed_1_2)



### 自定义离线安装脚本

#### install-uv.ps1

```powershell
$installDir = "D:\uv"
$zipFile = ".\uv-x86_64-pc-windows-msvc.zip"

# 创建目录并解压
New-Item -ItemType Directory -Force -Path $installDir | Out-Null
Expand-Archive -LiteralPath $zipFile -DestinationPath $installDir -Force

# 获取当前用户 PATH
$oldPath = [Environment]::GetEnvironmentVariable("Path", "User")
if ($null -eq $oldPath) { $oldPath = "" }

# 判断 PATH 是否包含安装目录
if ($oldPath -notmatch [Regex]::Escape($installDir)) {
    $newPath = if ($oldPath -eq "") { $installDir } else { "$oldPath;$installDir" }
    [Environment]::SetEnvironmentVariable("Path", $newPath, "User")
    Write-Host "✅ 已将 $installDir 添加到用户 PATH"
} else {
    Write-Host "ℹ️ PATH 已包含 $installDir"
}

# 提示刷新 PATH
Write-Host ""
Write-Host "🚀 请重新打开 PowerShell 或 CMD 会话，然后执行："
Write-Host "   uv --version"
Write-Host ""

```



### 安装方法

1. 将以下两个文件放在同一目录：

```
uv-x86_64-pc-windows-msvc.zip
install-uv.ps1
```

2. 右键点击 **PowerShell** → 选择 **以管理员身份运行**。

3. 在该目录下执行：

```powershell
powershell -ExecutionPolicy Bypass -File .\install-uv.ps1
```

4. 安装完成后，**重新打开 PowerShell** 并验证安装：

```powershell
uv --version
```

若看到类似输出：

```
uv 0.9.7 (0adb44480 2025-10-30)
```

说明安装成功 🎉





---



## Linux [官方安装教程](https://docs.astral.sh/uv/getting-started/installation/#__tabbed_1_1)

### 自定义离线安装脚本

#### install-uv.sh

```bash
#!/bin/bash

# 安装目录与压缩包路径
install_dir="$HOME/uv"
tar_file="./uv-x86_64-unknown-linux-gnu.tar.gz"

# 创建目录并解压
mkdir -p "$install_dir"
tar -xzf "$tar_file" -C "$install_dir" --strip-components=1

# 检查 PATH 是否已包含安装目录
if [[ ":$PATH:" != *":$install_dir:"* ]]; then
    # 自动判断使用 bash 还是 zsh
    shell_rc="$HOME/.bashrc"
    if [ -n "$ZSH_VERSION" ]; then
        shell_rc="$HOME/.zshrc"
    elif [ -n "$BASH_VERSION" ] && [ -f "$HOME/.bash_profile" ]; then
        shell_rc="$HOME/.bash_profile"
    fi

    # 添加到 PATH
    echo "" >> "$shell_rc"
    echo "# UV CLI 安装路径" >> "$shell_rc"
    echo "export PATH=\"$install_dir:\$PATH\"" >> "$shell_rc"
    echo "✅ 已将 $install_dir 添加到 PATH（写入 $shell_rc）"
else
    echo "ℹ️ PATH 已包含 $install_dir"
fi

# 设置执行权限
chmod +x "$install_dir/uv" 2>/dev/null || true

# 提示刷新 PATH
echo ""
echo "🚀 请重新打开终端，或执行以下命令立即生效："
echo "   source ~/.bashrc   # 或 source ~/.zshrc"
echo ""
echo "安装完成后可验证："
echo "   uv --version"
echo ""
```

------

### 安装方法

1. 将以下两个文件放在同一目录：

```
uv-x86_64-unknown-linux-gnu.tar.gz
install-uv.sh
```

2. 给予安装脚本执行权限：

```bash
chmod +x install-uv.sh
```

3. 在该目录下执行：

```bash
bash install-uv.sh
```

4. 安装完成后，**重新打开终端** 并验证安装：

```bash
uv --version
```

若看到类似输出：

```
uv 0.9.7
```

说明安装成功 🎉

------

是否希望我顺带加上 macOS 版本（保持相同风格）？这样三平台文档就完整了。





---



## 使用方法

#### 在已有项目中使用UV

``` bash
# 为当前项目初始化一个虚拟环境，并指䃾Python的版本
uv venv -p 3.12
## 这会在当前项目默认创建一个名为.venv的文件夹

# 为当前项目初始化必要的配置文件
uv init
## 这会在当前项目中创建 main.py、.python-version、pyproject.toml 等多个文件

# 下载当前项目的依赖
uv add -r .\requirements.txt
## 最终会将依赖配置自动补充到 pyproject.toml 文件中

```



#### 使用UV创建一个新项目

``` bash
# 初始化一个项目，并指定Python的版本
uv init <项目名> -p 3.12

# 进入生成的项目目录
cd <项目名>

# 生成虚拟环境（可以不执行，uv add 或 run 会自动创建）
uv venv

# 基于uv安装项目依赖
uv add <依赖名==版本号>

# 运行
uv run main.py
```



#### 使用UV切换当前项目的Python版本

``` bash
# 切换当前项目Python版本为 3.12
uv venv -p 3.12

# 切换当前项目Python版本为 3.10
uv venv -p 3.10

```

> 提示：在 `Add Python Interpreter` 的 Virtualenv Environment 选项卡下选择 `Existing`，PyCharm 会自动识别项目中 uv 管理的现有虚拟环境。





---





## Conda 和 UV 的区别



Conda 和 UV 在 **环境管理方式** 上差异很大，理解这个差异对实际使用很关键。我帮你详细对比一下两者的环境管理特点：

| 特性                | Conda 环境                                                   | UV 环境                                                      |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **环境创建**        | 手动创建，明确指定环境名：`conda create -n myenv python=3.10` | 自动创建或切换 Python 版本：`uv use python@3.11`，可自动生成隔离环境 |
| **激活方式**        | 必须手动激活：`conda activate myenv`                         | 随 Python 版本切换自动激活，或者用 `uv shell` 进入环境       |
| **环境命名**        | 显式命名，每个环境独立                                       | 不需要手动命名，每个 Python 版本对应隔离环境，或项目自动使用 `uv.lock` 管理依赖 |
| **依赖隔离**        | 每个环境都是完整隔离的独立环境                               | UV 使用全局缓存 + 项目隔离，重复依赖不重复下载，磁盘占用更低 |
| **环境列表**        | `conda env list`                                             | `uv list` 或通过 `.uv/` 目录查看本项目 Python 版本和依赖环境 |
| **Python 版本管理** | 通过创建新环境指定 Python 版本                               | 内置 Python 版本管理，可按需下载并切换 `uv use python@3.12`  |
| **导出/共享环境**   | `conda env export > environment.yml`                         | 内置 `uv.lock` 文件自动锁定依赖，跨机器直接可复现            |
| **多项目支持**      | 每个项目创建独立环境，手动维护                               | 支持 Cargo 风格工作区，多项目共享依赖，同时锁文件保证版本一致 |
| **磁盘使用**        | 每个环境独立，占用多份相同依赖                               | 全局缓存机制，重复依赖只存一份，节省空间                     |

💡 **核心区别**：

1. **Conda**：每个环境独立，手动管理，需要显式激活；适合科学计算或多语言依赖场景。
2. **UV**：自动化、轻量化，环境与 Python 版本管理高度集成，依赖锁文件 + 全局缓存实现高效共享和跨项目复用。

可以说，**UV 的环境更像“项目绑定的隔离层+全局缓存”**，而 Conda 则是“每个环境独立、明确分隔”的传统模式。



---



> UV 的 **“项目绑定的隔离层 + 全局缓存”**机制听起来很方便，但实际使用中确实需要理解哪些东西在项目隔离层，哪些东西在全局缓存，以及如何避免相互影响。我们来拆解一下：



### 1️⃣ UV 的隔离层 vs 全局缓存

| 特性            | 项目绑定的隔离层                                             | 全局缓存                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **作用**        | 保存当前项目特定的依赖、Python 版本和锁定状态                | 保存已下载的依赖包、Python 版本和构建产物，以便跨项目重用    |
| **典型内容**    | `.uv/` 目录下的虚拟环境、`.uv/uv.lock` 文件中锁定的依赖版本  | `~/.uv/cache/` 或系统默认缓存目录，存放所有下载过的包和 Python 版本 |
| **隔离粒度**    | 按项目（或按 uv shell 激活）                                 | 跨项目共享，缓存只读，不直接影响项目                         |
| **修改行为**    | 项目安装新依赖、升级依赖时修改隔离层                         | 全局缓存保持不变，除非 UV 主动清理缓存或下载新版本           |
| **删除影响**    | 删除项目隔离层只影响当前项目                                 | 清理全局缓存会影响所有项目依赖再次下载，但不会破坏隔离层已有环境 |
| **Python 版本** | 如果项目指定了特定 Python 版本，会在隔离层创建软链接到全局缓存下载的 Python | 下载的 Python 二进制文件存放在全局缓存，多个项目可复用       |



### 2️⃣ 工作原理示意

1. **全局缓存**
   - 第一次安装依赖或 Python 版本时，UV 会下载到全局缓存（类似 pip 的 `~/.cache/pip`）。
   - 缓存中的内容是 **只读的**，不会被单个项目直接改动。
2. **项目绑定隔离层**
   - UV 在 `.uv/` 下为每个项目生成独立虚拟环境。
   - 这些虚拟环境通过 **软链接或复制**方式引用全局缓存的依赖或 Python 可执行文件。
   - 这样每个项目都能独立使用自己的依赖版本，同时共享缓存避免重复下载。
3. **依赖升级和锁文件**
   - 当你在项目中安装或升级包时，隔离层会修改 **软链接或指向**，但全局缓存保持不变。
   - `uv.lock` 锁定当前项目的依赖版本，确保跨机器或团队一致性。



### 3️⃣ 关键优势

- **节省磁盘空间**：相同依赖只存一份在全局缓存，多项目复用。
- **隔离性仍然保留**：项目升级依赖不会影响其他项目，因为隔离层独立管理依赖版本。
- **安全性**：全局缓存可视为只读资源，项目间不会互相污染。



### 💡 **总结**：

- **全局缓存 = 原材料仓库**，只存放已下载的依赖和 Python，可被多个项目重用。
- **项目隔离层 = 工作环境**，依赖版本由锁文件管理，修改只影响本项目，隔离层通过软链接使用缓存里的内容。
