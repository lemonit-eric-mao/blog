---
title: "SeekDB 执行计划对比与讲解"
date: "2025-12-16"
categories: 
  - "databases"
---



# SeekDB 执行计划对比与讲解



### [官方文档-体验向量搜索](https://www.oceanbase.ai/docs/zh-CN/experience-vector-search#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93)



### 创建表+数据

``` sql
create table t1(
    id INT primary key, 
    doc VARCHAR(200),
    embedding VECTOR(3), 
    VECTOR index idx1(embedding) with (distance = L2, type = hnsw)
);


INSERT INTO t1
VALUES (1, '苹果', '[1.2,0.7,1.1]'),
       (2, '香蕉', '[0.6,1.2,0.8]'),
       (3, '橙子','[1.1,1.1,0.9]'),
       (4, '胡萝卜', '[5.3,4.8,5.4]'),
       (5, '菠菜', '[4.9,5.3,4.8]'),
       (6, '西红柿','[5.2,4.9,5.1]');

```



### 讲解两个seekdb的执行计划



#### sql1

``` sql
EXPLAIN SELECT id, doc FROM t1
ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
APPROXIMATE LIMIT 3;
```

#### sql2

``` sql
EXPLAIN SELECT id, doc FROM t1
ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
LIMIT 3;
```



#### 执行计划

##### 基于向量索引的执行计划

```
=====================================================
|ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|
-----------------------------------------------------
|0 |VECTOR INDEX SCAN|t1(idx1)|1       |20          |
=====================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.id], [t1.doc]), filter(nil), rowset=16
      access([t1.id], [t1.doc]), partitions(p0)
      is_index_back=true, is_global_index=false, 
      range_key([t1.__vid_1765851143867161], [t1.__type_18_1765851143867325]), range(MIN,MIN ; MAX,MAX)always true
```

##### 基于全表扫描的执行计划

```
=================================================
|ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
-------------------------------------------------
|0 |TOP-N SORT       |    |3       |3           |
|1 |└─TABLE FULL SCAN|t1  |6       |3           |
=================================================
Outputs & filters:
-------------------------------------
  0 - output([t1.id], [t1.doc]), filter(nil), rowset=16
      sort_keys([l2_distance(t1.embedding, cast('[0.9, 1.0, 0.9]', ARRAY(18, -1))), ASC]), topn(3)
  1 - output([t1.id], [t1.embedding], [t1.doc]), filter(nil), rowset=16
      access([t1.id], [t1.embedding], [t1.doc]), partitions(p0)
      is_index_back=false, is_global_index=false, 
      range_key([t1.id]), range(MIN ; MAX)always true
```



---



下面我结合 **两个 SQL** 和 **对应的执行计划**，从「为什么会这样选计划」以及「每个算子在干什么」两个角度，系统讲解这 **两个 seekdb 的执行计划差异**。

------

## 一、两个 SQL 的核心差别

### SQL1（近似向量检索）

```sql
ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
APPROXIMATE LIMIT 3;
```

**关键点：**

- 使用了 `APPROXIMATE`
- 允许 **近似 TopK**
- 数据库可以使用 **向量索引（ANN Index）**

------

### SQL2（精确向量排序）

```sql
ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
LIMIT 3;
```

**关键点：**

- 没有 `APPROXIMATE`
- 要求 **精确 TopK**
- 必须对 **所有行计算距离并排序**

------

👉 **本质区别一句话总结：**

> **SQL1 是“用索引近似找最像的几个”**
> **SQL2 是“算完所有距离后再精确排序”**

------

## 二、SQL1：基于向量索引的执行计划（ANN）

### 执行计划

```
|0 |VECTOR INDEX SCAN|t1(idx1)|1 |20|
```

### 执行逻辑拆解

#### 1️⃣ VECTOR INDEX SCAN

这是 **向量索引扫描算子**，说明：

- `t1(idx1)`：使用了表 `t1` 上的向量索引 `idx1`
- 不是扫描整表
- 索引内部已经组织好了向量空间结构（如 HNSW / IVF 等）

👉 **核心行为：**

- 在索引结构中 **近似搜索距离最近的向量**
- 不需要访问全表数据

------

#### 2️⃣ ORDER BY 被“下推”进索引

```text
ORDER BY l2_distance(...)
```

在这里：

- `ORDER BY + APPROXIMATE + LIMIT`
- 被优化器识别为 **ANN TopK 查询**
- 排序逻辑 **不再是 Sort 算子**
- 而是由 **向量索引本身完成**

------

#### 3️⃣ LIMIT 3 的真实执行方式

你看到：

```text
rowset=16
EST.ROWS=1
```

这表示：

- 索引内部会 **多取一些候选（如 16 条）**
- 再从中选出 Top 3
- 这是 **近似搜索的典型特征**

------

#### 4️⃣ is_index_back = true

```text
is_index_back=true
```

说明：

- 向量索引中 **不包含 doc 字段**
- 需要根据索引返回的 rowid **回表取 id、doc**

------

### SQL1 总结

✅ **这是一个典型的向量 ANN 查询**

特点：

- 不扫描全表
- 不显式排序
- 时间复杂度 ≈ `O(log N)`
- 速度快
- 结果是近似的，但通常足够好

------

## 三、SQL2：基于全表扫描 + 精确排序

### 执行计划

```
|0 |TOP-N SORT       |
|1 |└─TABLE FULL SCAN|t1|
```

------

### 执行逻辑拆解

#### 1️⃣ TABLE FULL SCAN

```
TABLE FULL SCAN | t1
```

说明：

- **扫描 t1 的所有行**

- 取出：

  ```text
  id, embedding, doc
  ```

👉 **原因：**

- `l2_distance()` 是运行时计算
- 没有 APPROXIMATE
- 不能使用向量索引来“跳过数据”

------

#### 2️⃣ 计算每一行的 l2_distance

```text
l2_distance(t1.embedding, '[0.9, 1.0, 0.9]')
```

- 对 **每一行 embedding** 计算一次
- 这是 CPU 密集操作

------

#### 3️⃣ TOP-N SORT

```
TOP-N SORT
sort_keys(l2_distance(...)), topn(3)
```

这是一个 **优化过的排序算子**：

- 并不是全排序
- 而是 **边扫描边维护一个 Top 3 的最小堆**
- 但前提仍然是：**所有行都要算一遍距离**

------

### SQL2 总结

✅ **这是一个精确 TopK 查询**

特点：

- 必须扫描全表
- 必须计算所有向量距离
- 必须进行排序（或 Top-N）
- 时间复杂度 ≈ `O(N)`

------

## 四、两个执行计划的对比总结

| 对比维度         | SQL1（APPROXIMATE）        | SQL2（精确）     |
| ---------------- | -------------------------- | ---------------- |
| 是否使用向量索引 | ✅ 是                       | ❌ 否             |
| 扫描方式         | VECTOR INDEX SCAN          | TABLE FULL SCAN  |
| 是否计算所有距离 | ❌ 否                       | ✅ 是             |
| 排序方式         | 索引内部完成               | TOP-N SORT       |
| 是否回表         | 可能（is_index_back=true） | 不需要           |
| 性能             | 非常快                     | 随数据量线性增长 |
| 结果准确性       | 近似                       | 精确             |

------

## 五、一句话结论（非常重要）

> **APPROXIMATE 是是否能使用向量索引的“开关”**

- 有 `APPROXIMATE` → **ANN 向量索引**
- 没有 `APPROXIMATE` → **全表扫描 + 排序**

------

### 六、验证rowset的值是根据什么变化的

原表中数据`6条` --> 增加到 `30条`，再次执行查询计划 `rowset = 16   --->  rowset = 256`

> **实验明了：seekdb 的 `rowset` 是一个“与数据规模强相关的自适应 ANN 搜索宽度”，而不是一个简单的 LIMIT 放大系数。**

这已经是**非常接近向量数据库内核层的理解了**。