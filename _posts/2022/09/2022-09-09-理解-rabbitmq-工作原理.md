---
title: "理解 RabbitMQ 工作原理"
date: "2022-09-09"
categories: 
  - "mq"
---

##### 前置资料

**[官方文档](https://www.rabbitmq.com/getstarted.html "官方文档")**

* * *

###### 最简单的 消息队列

![](images/rabbitmq-simple.png)

* * *

##### **Work queues 竞争消费者模式**

> - **工作队列**（又名：**任务队列**）背后的主要思想是**避免立即执行资源密集型任务**而不得不等待它完成。相反，我们**将任务安排在以后完成**。 我们将任务封装为消息并将其发送到队列，在后台运行的工作进程将弹出任务并最终执行作业。**当您运行许多消费者时，任务将在他们之间共享**。 ![](images/rabbitmq-workqueues.png)
> - 这个概念在 Web 应用程序中特别有用，在这些应用程序中，无法在短暂的 HTTP 请求窗口中处理复杂的任务。

* * *

##### **Publish/Subscribe 一次向多个消费者发送同一条消息**

向多个消费者传递同一条消息。这种模式被称为【**发布/订阅**】。

> - **`快速回顾一下`**
>     - **生产者**是发送消息的用户应用程序。
>     - **队列**是存储消息的缓冲区。
>     - **消费者**是接收消息的用户应用程序。
> - **在 `RabbitMQ` 中消息传递模型的核心思想是`生产者从不直接向队列发送任何消息`**。实际上，**生产者通常根本不知道消息是否会被传递到任何队列**。
> - `相反`，**生产者只能向`交换器`发送消息**。 `交换`是一件非常简单的事情。一方面它接收来自生产者的消息，另一方面它将收到的消息推送到队列中。 `交换`必须确切地知道如何处理它收到的消息。是否应该将消息推送到特定队列？它应该推送到许多队列中吗？或者它应该被丢弃。 ![](images/rabbitmq-publish-subscribe.png)

* * *

##### **Routing (路由 binding)**

> - **`绑定`的是交换和队列之间的关系。可以简单地理解为：队列只关注来自此交换的消息**
>     - `绑定`还可以采用额外的**routing\_key**参数。为了避免与`basic_publish`参数混淆，我们将其称为 `binding_key`。 `binding_key` 的含义取决于 **`交换类型`**。 这就是我们如何使用键创建绑定：
>         
>         ```python
>         channel.queue_bind(exchange=exchange_name,
>                        queue=queue_name,
>                        routing_key= 'black' )
>         ```
>         

* * *

> - **可用的`交换类型`：**
>     - **direct**
>         - **`direct` exchange** 背后的路由算法很简单，消息会进入`binding_key`与`routing_key`完全匹配的队列。 ![](images/rabbitmq-direct-1.png)第一个队列使用 **binding\_key** `v1` 进行绑定；第二个队列有两个 **binding\_key**，一个使用 `v2`，另一个使用`v3` 当使用**routing\_key=v1**发布到交换的消息 将被路由到队列 **`Q1`** 当使用**routing\_key=v2或routing\_key=v3**发布到交换的消息 将被路由到队列 **`Q2`**
>         - **多个绑定** ![](images/rabbitmq-direct-2.png)使用相同的 **binding\_key** 绑定多个队列是完全合法的。在这种情况下， **`direct` exchange** 的行为类似于 **`fanout` exchange** 并将消息广播到所有匹配的队列。
>     - **topic**
>         - 尽管使用 **`direct` exchange** 改进了我们的系统，但它仍然有局限性——**它`不能基于多个标准`进行路由**。
>         - **`topic` exchange** 背后的逻辑类似于 **`direct` exchange**，可以简单的理解为，通过正则匹配所有队列。
>         - 但是，对于 **binding\_key** 的正则使用有两个重要的特殊情况(**这也是它与`direct`的区别**)：
>             - **`*`（星号）**可以只替换一个单词。
>             - **`#` (hash)** 可以代替零个或多个单词。 ![](images/rabbitmq-topic-0.png)
>     - **headers**
>     - **fanout**
>         - `fanout` 交换，它并没有给我们太多的灵活性——它只能进行无意识的广播。使用`fanout` 交换是忽略了**routing\_key**的价值

* * *

##### **RPC**

> - **需求场景**：如果我们需要在 **`远程计算机上`运行一个函数** 并等待结果呢？ 这种模式通常称为**远程调用**或**RPC**。
> - **个人理解**：所以这里的**RPC**是为**远程调用的需求**也提供了一个**消息队列**功能。

* * *

##### 个人总结

> - 通过上面的官方文档介绍，从一个最简单最初级的消息队列，在经过实际问题锤炼加以不断的完善，直到最后 **topic**类型的**交换器**诞生，描述了RabbitMQ的由来和工作原理，其实在最后生产环境中，我们只使用**topic**交换器，就可以满足了所有的应用场景。
