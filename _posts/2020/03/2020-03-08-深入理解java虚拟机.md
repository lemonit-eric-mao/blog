---
title: "深入理解Java虚拟机"
date: "2020-03-08"
categories: 
  - "java"
---

##### 学习资料

**[JVM在什么时候启动的](https://blog.csdn.net/m0_37742084/article/details/80151752 "JVM在什么时候启动的")**

**[学前准备](%E5%A4%A7%E5%A4%84%E7%9D%80%E7%9C%BC%EF%BC%8C%E5%B0%8F%E5%A4%84%E8%90%BD%E6%89%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA "学前准备")**

**[成达博客](https://www.cnblogs.com/chinda/ "成达博客")**

* * *

* * *

* * *

#### 一、先了解 Java是如何控制内存的

##### 内存分配的两种方式 (深入Java虚拟机 44页)

1 指针碰撞 Bump the Pointer 2 空闲列表 Free List

  选择哪种分配方式由`Java堆内存是否规整`决定， 而Java堆是否规整，又由所采用的`垃圾收集器`是否带有`压缩整理功能`决定。

* * *

###### **指针碰撞**

![](images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-01.gif)

* * *

###### **空闲列表**

空闲列表，顾名思义，记录空闲内存的列表。   因为`已使用的内存`和`空闲的内存相互交错`，虚拟机就必须维护一个列表，**记录上哪些内存块是可用的**，在分配的时候从列表中找到一块足够大的空间划分给对象实例。 ![](images/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-02.gif)

* * *

* * *

* * *

##### 对象的内存布局

**分为三个部分**：

1. 对象头(**Header**)   对象头包括两类信息 第一类：用于存储对象自身的运行时数据，如 HashCode、GC分代年龄、锁状态标志、线程持有的锁等 第二类：`类型指针`，即对象指向它的类型的元数据的指针，Java 虚拟机通过这个指针来确定`该对象是哪个类的实例`。
2. 实例数据(Instance Data)   对象实例本身
3. 对齐填充(Padding)   对齐填充， 没有什么特别的含义，因为HotSpot VM要求对象的大小都必须是8字节的整数倍。对象头已经被设计成正好是8字节的倍数，对象的实体有可能部分不是8字节的倍数，因此，就需要通过对齐填充来补全

* * *

* * *

* * *

##### 分代收集理论

1. 弱分代假说（**Weak Generational Hypothesis**）：绝大多数对象都是朝生夕灭的(`新生代对象`)。
2. 强分代假说（**Strong Generational Hypothesis**）：熬过越多次垃圾收集过程的对象就越难以消 亡(`老年代对象`)。
3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极 少数。

* * *

* * *

* * *

* * *

  程序员编写Java代码 **`-->`** Java编译器将代码编译成`.class`文件 **`-->`** java -jar 初始化虚拟机加载`.class`文件 **`-->`** 主线程开始工作

* * *

* * *

* * *

* * *

#### 二、了解`JVM 是如何工作的`

1. **要知道`什么是JVM`：**   可以先简单的认为jvm是一个系统的动态链接库，它与docker和vmware不同，它是当执行java命令时才启动，实际上是启动一个进程，启动时根据**`虚拟机参数`(例如：-Xmx2048m -Xms2048m)** 在这个进程中开辟出`栈、方法区、堆`等虚拟区域。 **JVM虚拟机与 docker虚拟化 vmware 虚拟机，概念不搭边，初学时不要往上面联想，以免走偏** docker是先启动一个守护进程，进入待命状态，通过`网络请求来接收`指令(socker/tcp都可以) vmware是启动以后，在里面创建副本
    
2. **Java代码的`编译器`：**   java的编译器先将java代码编译成虚拟机能够识别的class指令集文件， 比如说哪些类型数据放在栈中，哪些类型数据要在堆中创建，哪些类型数据要放到方法区等等等等，一些可以预知的都是在编译期编译好了，然后写在class文件中
    
3. **什么是`class文件`：**   可以想象成是一个模板，这个模板中全部是虚拟可以理解的指令集(一大堆命令，只有虚拟机才看的懂)
    
4. **`读取class文件`：**   将class文件`交给虚拟机处理`的时候，虚拟机先校验这个文件的合法性，然后在对这个指令集进行解析，当初始化时，虚拟机会按照class中的指令，在栈、方法区、堆中做出相应的操作(开辟空间、添加引用、基础数据与常量数据赋值等等操作)
    
5. **`类加载器`：**   虚拟机`首先`加载`JAVA_HOME/lib/`目录中Java虚拟机能够识别的文件由`Bootstrap Class Loader加载器`加载, `然后`如果想`扩展`Java SE的功能我们可以在`JAVA_HOME/lib/ext`目录中自己扩展类库，这样的类库由`Extension Class Loader加载器`加载, `最后`一个是我们程序员开发的`Java代码`编译后会放在`ClassPath`目录中，这些文件由`Application Class Loader加载器`加载
    
6. **`main函数`：**   通过执行 main函数开始，进程中`第一次`开启了主线程，主线程开始执行 jvm中的各个指令
    

* * *

* * *

* * *

###### `动态`、`静态`类型语言两者`谁更好？`，或者谁更加先进呢？

  这种比较不会有确切答案，它们都有自己的优点，选择哪种语言是需要权衡的事情。   `静态类型语言`能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。   而`动态类型语言`在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。
