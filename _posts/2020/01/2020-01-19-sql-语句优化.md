---
title: "SQL 语句优化"
date: "2020-01-19"
categories: 
  - "mysql"
---

**1.** 对于要求全面的结果时，我们需要使用连接操作（**LEFT JOIN** / **RIGHT JOIN** / **FULL JOIN**）；

* * *

**2.** 应尽量避免在 **WHERE** 子句中对字段进行 **NULL** 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
SELECT id FROM t WHERE num IS NULL;
```

  备注、描述、评论之类的可以设置为 **NULL**，其他最好不要使用**NULL**。   不要以为 **NULL** 不需要空间，比如：**char(100)** 型，在字段**建立时，空间就固定了**， 不管是否插入值（NULL也包含在内），都是**占用 100个字符空间**的，如果是**varchar**这样的**变长字段**， **null 不占用空间**。   可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

```sql
SELECT id FROM t WHERE num = 0;
```

* * *

**3.** IN 和 NOT IN 也要慎用，否则会导致全表扫描，如：

```sql
SELECT id FROM t WHERE num IN(1,2,3);
```

`注：`IN的用法与**[TiDB联合索引](tidb-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E6%9E%9C%E5%B7%A5%E4%BD%9C%E7%9A%84 "TiDB联合索引")** 有区别

* * *

**4.** 对于连续的数值，能用**between**就不要用**in**了，如：

```sql
SELECT id FROM t WHERE num BETWEEN 1 AND 3;
```

* * *

**5.** 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

* * *

**6.** 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

* * *

**7.** 不要以为使用MySQL的一些连接操作对查询有多么大的改善，其实核心是索引

* * *

**8.** 注意不要在语句中发生数据类型的强制转换，如： **num VARCHAR(255)**类型，在使用中 **num = 10**, 在执行中数据库引擎会这样做`eq(cast(num), 10)`

* * *

**9.** 大表关联，**第一**、要想尽办法减少主表的数量 **第二**、不要使用子表的字段做为查询条件

* * *
